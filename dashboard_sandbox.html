<!DOCTYPE html>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta charset="utf-8">
<head> 
<link rel="stylesheet" type="text/css" href="libarys/datepicker.css" /> 
<style> 

html, body{
	margin: 0;
	padding: 0;
	}
	
div.tooltip {
	color: #222; 
	background: #fff; 
	padding: .5em; 
	font-family: PT Sans;
	border-radius: 2px; 
	box-shadow: 0px 0px 2px 0px #a6a6a6; 
	opacity: 0.9; 
	position: absolute;	
	width: 140px !important; min-width: 140px; max-width: 140px
	}

.hidden { 
	display: none; 
	}

.hed {
	font-family: PT Sans;
	font-size: 30pt;
	font-weight: bold;
	margin-top:0px;
	margin-left:18px;
	margin-bottom:0px; 
	float: left;
	}

.clear-button {
  font-family: PT Sans;
  font-size: 15pt;
  cursor: pointer;
}

.grey-button {
  font-family: PT Sans;
  font-size: 12pt;
  border:1px solid black;
  cursor: pointer;
}

.menuchoice {
	font-family: PT Sans;
	font-size: 12pt;
	margin-bottom:0px; 
	margin-top:15px;
	float: right;
	fill: #231F20; 
	}
	
.graph {
    float: left;
	background-color:White;
	border:1px solid #00305d;
	margin-left:5px;
	margin-top:5px;
	}
	 
.axis text {
	font-family: PT Sans;
	font-size: 10pt;
	}

.text{
	font-family: PT Sans;
	font-size: 6pt;
	}  

.axis line,
.axis path {
	fill: none;
	stroke: grey;
	stroke-width: 1px;
	opacity: 0.2;
	}

	
	
path { 
    stroke: black;
    stroke-width: 0.5px;
    fill: none;
	}

.legend {
	font-family: PT Sans;
    font-size: 15px;
	}
.browser text {
  text-anchor: end;
}	
	
.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}	

/* The Modal (background) */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    padding-top: 67px; /* Location of the box */
    left: 15px;
    top: 0;
    width: 170px; 
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0); /* Black w/ opacity */
}

/* Modal Content */
.modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
	font-family: PT Sans;
	 font-size: 12px;
    width: 80%;
}

/* The Close Button */
.close {
    color: #aaaaaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}

.close:hover,
.close:focus {
    color: #000;
    text-decoration: none;
    cursor: pointer;
}

</style>
</head>
<body>
<script src="libarys/d3.v3.min.js"></script>
<script src="libarys/queue.v1.min.js"></script>
<script src="libarys/topojson.v1.min.js"></script>
<script src="libarys/d3.geo.projection.v0.min.js"></script>
<script src="libarys/colorscale.js"></script>
<script src="libarys/contrylist.js"></script>
<script src="libarys/myfunctions.js"></script>
<script type="text/javascript" src="libarys/datepicker.js"></script>


<div   id="complscreen" style="width: 1890px;height: 1050px;background-color: white;"> 
	<div style="height: 10px;" id="Space"> </div>  	
		<p id="headline" align="left" class="hed" style="width: 1850px">	<font   color="#00305d">Power</font><font color="#E2001a">2</font><font color="#00305d">Sim Dashboard</font> 

			<input name="helpbutton" align="right" type="button" value="?"  style="margin-top:20px;margin-right:5px;float: right" onclick="helpmenu()" />	
			<img style="margin-right:15px;margin-top:10px;float: right" src="./logo.png" align="right" width="204" height="35" alt="logo" onclick="location.reload(true)"> 
			<p id="szen" align="left" style="margin-left:460px;margin-top:20px;position:absolute;" class="menuchoice">Szenario 
				<select  id="szenario"style="width: 400px !important; min-width: 400px; max-width: 400px;">
					<option selected value="DashBoard2050/">Standardszenario 2005 - 2050</option>
				</select>
			</p>
			<p id="szen2" align="left" style="margin-left:1060px;margin-top:20px;position:absolute;" class="menuchoice">
						
				<select  id="szenario2"style="width: 400px !important; min-width: 400px; max-width: 400px;">
					<option selected value="DashBoard2050/">Standardszenario 2005 - 2050</option>
				</select>
			</p>		
		</p>
	<div style=" margin-left:5px; float: left;">
		<div style="background-color:White; border: 1px solid #00305d; height: 993px; margin-left:10px; margin-bottom:0px; margin-top:5px; width:170px;   float: left"id="container" align="left">
			<div style="height: 10px;" id="Space"> </div> 


			
						<p id="tables" style="margin-left:10px; ;margin-top:20px; float: left ;" align="left" class="menuchoice">Tables 
				<select   id="series"style="width: 150px !important; min-width: 150px; max-width: 150px">
					<option value='Power-Sector'>Power-Sector</option>
					<option  value='Commodities' >Commodities</option>
					<option value='Import-Export'>Import-Export</option>
					<option value='Overview'>Overview</option>
					<option value='Wind'>Wind</option>
					<option value='Temperatur'>Temperatur</option>
					<option value='Radiation'>Radiation</option>
					<option value='Compare'>Compare</option>
					<option value='Compare-Maps'>Compare-Maps</option>
					<option value='Stylesheets/windger.csv'>Wind in D</option>	
					<!-- <option value='Stylesheets/firstrenew.csv'>Dunkelflaute</option> -->
				</select>
			</p>
			
			<p id="reso" style="margin-left:10px; margin-top:20px; float: left ;" align="left" class="menuchoice">Resolution 
				<select id="resolution"style="width: 150px !important; min-width: 150px; max-width: 150px;">
					<option value="y">Yearly</option>
					<option  value="m" >Monthly</option>
					<option value="d">Daily</option>
					<option value="h">Hourly</option>
				</select>
			</p>
		
			<p id="drpdwn" style="margin-left:10px; margin-top:20px;  float: left";align="left" class="menuchoice">Country 
				<select id="cntry"style="width: 150px !important; min-width: 150px; max-width: 150px;">	
					<option  value="Albania"   >Albania</option>
					<option value="Austria">Austria</option>
					<option value="Belarus">Belarus</option>
					<option value="Belgium">Belgium</option>
					<option value="Bosnia Herzegovina">Bosnia Herzegovina</option>
					<option value="Bulgaria">Bulgaria</option>
					<option value="Croatia">Croatia</option>
					<option value="Czech Republic">Czech Republic</option>
					<option value="Cyprus">Cyprus</option>
					<option value="Denmark">Denmark</option>
					<option value="Estonia">Estonia</option>
					<option value="Finland">Finland</option>
					<option value="France">France</option>
					<option selected value="Germany">Germany</option>
					<option value="Greece">Greece</option>
					<option value="Hungary">Hungary</option>
					<option value="Ireland">Ireland</option>
					<option value="Italy">Italy</option>
					<option value="Latvia">Latvia</option>
					<option value="Lithuania">Lithuania</option>
					<option value="Luxembourg">Luxembourg</option>
					<option value="Macedonia">Macedonia</option>
					<option value="Malta">Malta</option>
					<option value="Montenegro">Montenegro</option>
					<option value="Netherlands">Netherlands</option>
					<option value="Norway">Norway</option>
					<option value="Poland">Poland</option>
					<option value="Portugal">Portugal</option>
					<option value="Romania">Romania</option>
					<option value="Russia">Russia</option>
					<option value="Serbia">Serbia</option>
					<option value="Slovakia">Slovakia</option>
					<option value="Slovenia">Slovenia</option>
					<option value="Spain">Spain</option>
					<option value="Sweden">Sweden</option>
					<option  value="Switzerland"   >Switzerland</option>
					<option value="Ukraine">Ukraine</option>
					<option value="United Kingdom">United Kingdom</option>	
				</select>
			</p>
			<p style="margin-left:10px; float: left ;margin-top:20px;font-family: PT Sans ;" align="left">Startdate <input type="text" id="from" class='datepicker'style="width: 120px !important; min-width: 120px; max-width: 120px" value = "01-Jan-2005" placeholder="01-Jan-2005"> </p>		

			<p style="margin-left:10px; float: left;margin-top:10px;font-family: PT Sans ;" align="left">Enddate      <input type="text" id="to" class='datepicker' style="width: 120px !important; min-width: 120px; max-width: 120px"value = "31-Dec-2050" placeholder="31-Dec-2050"> </p>

			
			<input name="submit" align="center" type="button" value="Submit"  style="margin-left:40px;margin-top:30px;" onclick="change()" />	
		<!-- <div style=" border: 3px solid white; height: 0px; margin-top:10px; width:169px;   float: left align="left">-->
		</div>
		<div   id="tooltipGraph1"></div>
		<div   id="tooltipGraph2"></div>
		<div   id="tooltipGraph3"></div>
		<div   id="tooltipGraph4"></div>
		<div   id="tooltipGraph5"></div>
		<div   id="tooltipGraph6"></div>
		<div   id="tooltipGraph7"></div>
		<div   id="tooltipGraph8"></div>
		<div   id="tooltipGraph9"></div>
		<div   id="tooltipGraph10"></div>
		<div   id="tooltipGraph11"></div>
		<div   id="tooltipGraph12"></div>
	</div> 
	<div   id="Grapharea">
	
		<div  class="graph" id="Graph1"></div>
		<div  class="graph" id="Graph2"></div>
		<div  class="graph" id="Graph3"></div>
		<div  class="graph" id="Graph4"></div>
		<div  class="graph" id="Graph5"></div>
		<div  class="graph" id="Graph6"></div>
		<div  class="graph" id="Graph7"></div>
		<div  class="graph" id="Graph8"></div>
		<div  class="graph" id="Graph9"></div>
		<div  class="graph" id="Graph10"></div>
		<div  class="graph" id="Graph11"></div>
		<div  class="graph" id="Graph12"></div>
	</div>
		<div   id="btnDiv" style="width:395px; position:absolute;left:550px;top:70px " >
		   <input style="font-family: PT Sans ;" id="Autoscale" type="checkbox"  onchange="autoscalecheck(this)" checked> Autoscale <br>
			<input style="font-family: PT Sans ;" id="Crossborderflow" type="checkbox"  onchange="changes()" > Cross-Border <br>
		
		<!-- Trigger/Open The Modal -->
		<button id="myBtn"style=" position:absolute;top:10px;left:150px; ">Countries</button>

		<!-- The Modal -->
		<div id="myModal" class="modal">

			<!-- Modal content -->
			<div class="modal-content">
				<span class="close">&times;</span>
				<input type="checkbox" id="Albania"onchange="changecontry(this,id)"/>Albania<br>
				<input type="checkbox" id="Austria"onchange="changecontry(this,id)"/>Austria<br>
				<input type="checkbox" id="Belarus"onchange="changecontry(this,id)"/>Belarus<br>
				<input type="checkbox" id="Belgium"onchange="changecontry(this,id)"/>Belgium<br>
				<input type="checkbox" id="Bosnia Herzegovina"onchange="changecontry(this,id)"/>Bosnia Herzegovina<br>
				<input type="checkbox" id="Bulgaria"onchange="changecontry(this,id)"/>Bulgaria<br>
				<input type="checkbox" id="Croatia"onchange="changecontry(this,id)"/>Croatia<br>
				<input type="checkbox" id="Czech Republic"onchange="changecontry(this,id)"/>Czech Republic<br>
				<input type="checkbox" id="Cyprus"onchange="changecontry(this,id)"/>Cyprus<br>
				<input type="checkbox" id="Denmark"onchange="changecontry(this,id)"/>Denmark<br>
				<input type="checkbox" id="Estonia"onchange="changecontry(this,id)"/>Estonia<br>
				<input type="checkbox" id="Finland"onchange="changecontry(this,id)"/>Finland<br>
				<input type="checkbox" id="France"onchange="changecontry(this,id)"/>France<br>
				<input type="checkbox" id="Germany"onchange="changecontry(this,id)"/>Germany<br>
				<input type="checkbox" id="Greece"onchange="changecontry(this,id)"/>Greece<br>
				<input type="checkbox" id="Hungary"onchange="changecontry(this,id)"/>Hungary<br>
				<input type="checkbox" id="Ireland"onchange="changecontry(this,id)"/>Ireland<br>
				<input type="checkbox" id="Italy"onchange="changecontry(this,id)"/>Italy<br>
				<input type="checkbox" id="Latvia"onchange="changecontry(this,id)"/>Latvia<br>
				<input type="checkbox" id="Lithuania"onchange="changecontry(this,id)"/>Lithuania<br>
				<input type="checkbox" id="Luxembourg"onchange="changecontry(this,id)"/>Luxembourg<br>
				<input type="checkbox" id="Macedonia"onchange="changecontry(this,id)"/>Macedonia<br>
				<input type="checkbox" id="Malta"onchange="changecontry(this,id)"/>Malta<br>
				<input type="checkbox" id="Montenegro"onchange="changecontry(this,id)"/>Montenegro<br>
				<input type="checkbox" id="Netherlands"onchange="changecontry(this,id)"/>Netherlands<br>
				<input type="checkbox" id="Norway"onchange="changecontry(this,id)"/>Norway<br>
				<input type="checkbox" id="Poland"onchange="changecontry(this,id)"/>Poland<br>
				<input type="checkbox" id="Portugal"onchange="changecontry(this,id)"/>Portugal<br>
				<input type="checkbox" id="Romania"onchange="changecontry(this,id)"/>Romania<br>
				<input type="checkbox" id="Russia"onchange="changecontry(this,id)" disabled />Russia<br>
				<input type="checkbox" id="Serbia"onchange="changecontry(this,id)"/>Serbia<br>
				<input type="checkbox" id="Slovakia"onchange="changecontry(this,id)"/>Slovakia<br>
				<input type="checkbox" id="Slovenia"onchange="changecontry(this,id)"/>Slovenia<br>
				<input type="checkbox" id="Spain"onchange="changecontry(this,id)"/>Spain<br>
				<input type="checkbox" id="Sweden"onchange="changecontry(this,id)"/>Sweden<br>
				<input type="checkbox" id="Switzerland"onchange="changecontry(this,id)"/>Switzerland<br>
				<input type="checkbox" id="Ukraine"onchange="changecontry(this,id)"/>Ukraine<br>
				<input type="checkbox" id="United Kingdom"onchange="changecontry(this,id)"/>United Kingdom<br>
				<button id="EU27">EU27</button><br>
				<button id="enbrBt">EnergyBrainpool</button><br>
				<button id="AllBt">ALL</button><br>
				<button id="NoneBt">NONE</button><br>
				
			</div>

		</div>
		<p id="Coloursselcter" style="margin-left:10px; margin-top:10px; float: left ;" align="left" class="menuchoice">Colors
			<select id="Colours"style="width: 90px !important; min-width: 90px; max-width: 90px;">
				<option selected value="Standard">Standard</option>
				<option value="blue">blue</option>
				<option  value="red" >red</option>
				<option value="green">green</option>
				<option value="Temperatur">Temperatur</option>
			</select>
		</p>
		<p id="datasetselecter" style="margin-left:10px; margin-top:10px; float: left ;" align="left" class="menuchoice">Dataset
			<select id="dataset"style="width: 130px !important; min-width: 130px; max-width: 130px;">
				<option selected value="PowerPrice">Power Price</option>
				<option value="Demand">Demand</option>
				<option  value="NetImports" >Net Imports</option>
				<option  value="ResidualDemand" >Residual Demand</option>
				<option  value="Temperatur" >Temperatur</option>
				<option  value="Nuclear Capacities" >Nuclear Capacities</option>
				<option  value="Lignite Capacities" >Lignite Capacities</option>
				<option  value="Hard Coal Capacities" >Hard Coal Capacities</option>
				<option  value="Gas Capacities" >Gas Capacities</option>
				<option  value="Oil Capacities" >Oil Capacities</option>
				<option  value="Bio Capacities" >Bio Capacities</option>
				<option  value="Reservoir Capacities" >Reservoir Capacities</option>
				<option  value="Pump Capacities" >Pump Capacities</option>
				<option  value="Wind Capacities" >Wind Capacities</option>
				<option  value="Solar Capacities" >Solar Capacities</option>
				<option  value="Hydro Capacities" >Hydro Capacities</option>
			</select>
		</p>
		<p style="margin-left:10px; float: left;margin-top:20px;font-family: PT Sans ;" align="left">Map Scale Min.    <input type="text" id="mincosc" style="width: 60px !important; min-width: 60px; max-width: 60px"> </p>
		<p style="margin-left:10px; float: left;margin-top:20px;font-family: PT Sans ;" align="left">Max.    <input type="text" id="maxcosc" style="width: 60px !important; min-width: 60px; max-width: 60px" ></p>

	</div>
	
</div> 

<script>



//Datenpfade
z = document.getElementById("szenario");
szenario = z.value
datapath = szenario;
meteodatapath = "MeteoDaten/";

//Konstanten
typo = "PT Sans";
maxcharts = 12;   //maximale Anzahl von charts pro serie
initfirstdate = "01-Jan-2005";
lastdate = "31-Dec-2050";

//Szenarioliste laden aus Stylesheets/szenarios.csv
szenarios = []
szenariopath = []
d3.csv("Stylesheets/szenarios.csv", function(err, szenarioloader){
	szenarioloader.forEach(function(i){
	
		szenarios.push(i.name); 
		szenariopath.push(i.path);
	})
	var sel = document.getElementById('szenario');
	var sel2 = document.getElementById('szenario2');
	//style="width:395px; position:absolute;left:550px;top:70px 		
	for(var i = 0; i < szenarios.length; i++) {
		var opt = document.createElement('option');
		opt.innerHTML = szenarios[i];
		opt.value = szenariopath[i];
		sel.appendChild(opt);
	}
	for(var i = 0; i < szenarios.length; i++) {
		var opt = document.createElement('option');
		opt.innerHTML = szenarios[i];
		opt.value = szenariopath[i];
		sel2.appendChild(opt);
	}
})



//Startbildschirm (firstload)
firstdate = document.getElementById("from").value;
stylecsv = document.getElementById("series").value;
InputDateParse = d3.time.format("%d-%b-%Y").parse;
if (typeof mapdate !== 'undefined'){}
else { mapdate = InputDateParse(firstdate)}
selecteddate = mapdate
e = document.getElementById("cntry");
mapcountry = e.options[e.selectedIndex].value;
autoscalevalue =1;
loadcolorscale ();
loadcsv(stylecsv,firstdate,mapdate,mapcountry);
firsttimehere = 0
getcontrylist() //lädt die Länderlisten aus libarys/contrylist.js
showenbr() //lädt beim firstload die Länder aus der EnergyBrainpool Liste

// force data to update when menu is changed    
var menu = d3.select("#szen select")
    .on("change", changes); 
var menu = d3.select("#szen2 select")
    .on("change", changes);	
	var menu = d3.select("#tables select")
    .on("change", changes); 
var menu = d3.select("#drpdwn select")
    .on("change"  ,changes);   
var menu = d3.select("#reso select")
    .on("change", changes);
var menu = d3.select("#Coloursselcter select")
    .on("change", changes);  
var menu = d3.select("#datasetselecter select")
    .on("change", changes); 

	

// Get the modal
var modal = document.getElementById('myModal');

// Get the button that opens the modal
var ctbtn = document.getElementById("myBtn");
var btneu27 = document.getElementById("EU27");
var AllBt = document.getElementById("AllBt");
var NoneBt = document.getElementById("NoneBt");
var enbrBt = document.getElementById("enbrBt");
// Get the <span> element that closes the modal
var span = document.getElementsByClassName("close")[0];

// When the user clicks the button, open the modal 
ctbtn.onclick = function() {
    modal.style.display = "block";
}
//eu Button
enbrBt.onclick = function() {showenbr();change()}
btneu27.onclick = function() {showeurope();change()}
AllBt.onclick = function() {showallct(); change()}
NoneBt.onclick = function() {shownonect();change()}


// When the user clicks on <span> (x), close the modal
span.onclick = function() {
    modal.style.display = "none";
}

// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
    if (event.target == modal) {
        modal.style.display = "none";
    }
}
//alert message for no Data
function nodataalert(number,hourly){
if(hourly!="no"){
	text = number.append('text')
		.text('No Data available')
		.attr('dy','0.9em')
		}
}
//get stylesheet name and render svg

function loadcsv(csvname,firstdate,mapdate,mapcountry)
{
	z = document.getElementById("series");
	activetable = z.value
	if (activetable == "Compare" ||activetable == "Compare-Maps"){d3.select("#szenario2").classed("hidden", false)}
	else {d3.select("#szenario2").classed("hidden", true)}
	opp = 1;			//opacity of the Legend is set to 1 so it can change later on clicking
	if (typeof mapcountry == 'undefined'){
  		e = document.getElementById("cntry");
		mapcountry = e.options[e.selectedIndex].value;
	}
	//get the selected parameters
	fromdate 	= document.getElementById("from").value;
	todate 		= document.getElementById("to").value;
	r 			= document.getElementById("resolution");
	InputDateParse = d3.time.format("%d-%b-%Y").parse;
	InputYearParse = d3.time.format("%Y");
	InputMonthParse = d3.time.format("%b");
	InputMonthReParse = d3.time.format("%m");
	rseries = r.options[r.selectedIndex].value;
	InputStartDate = InputDateParse(firstdate);
	InputEndDate = InputDateParse(todate);
	InputStartYear = InputYearParse(InputStartDate);
	MapYear  = InputYearParse(mapdate);
	InputEndYear = InputYearParse(InputEndDate);
	InputStartMonth = InputMonthParse(InputStartDate);
	InputStartMonthNr = InputMonthReParse(InputStartDate);
	InputEndMonth = InputMonthParse(InputEndDate);
	InputEndMonthNr = InputMonthReParse(InputEndDate);
	if(InputStartDate > InputEndDate){alert ("End-Date is before Start-Date");return;}
	mouseover = []

	//get the stylesheetdata
	d3.csv("Stylesheets/style.csv", function(err, Graph) {
		for (chartno = 1;chartno<= maxcharts;chartno ++){
			graphchek =0;
			chnumber = "Graph"+chartno;	
			Graph.forEach(function(i){	
				if (typeof i.xmin === "undefined" || i.xmin === null || i.xmin === "") {}
				else {
					e = document.getElementById("from"); 
					f = document.getElementById("to"); 
					g =document.getElementById("resolution"); 
					if (g.value == i.reso && f.value == i.xmax){}
					else {
						g.value = i.reso; 
						e.value = i.xmin; 
						f.value = i.xmax; 
						NewDateParse = d3.time.format("%d-%b-%Y").parse
						mapdate = NewDateParse(i.xmin)
						selecteddate = mapdate
						changes();
					}
				}	
			
				if (i.table == csvname && i.number == chnumber){
					graphchek =1;
					addplot(i.number, i.width, i.height, i.type, i.csv_name, i.headline, i.strokewidth, i.ymin,i.ymax,i.cb,i.mapcolumn,mapdate,mapcountry,i.hourly,i.lines,avoidline[i.headline], colorscale[i.headline]);
				}		
			});
			if(graphchek == 0){
				addplot(chnumber,"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","");
				}
		}
	});
}

//create new Graphs

function addplot(gnumber, width, height, type, csv, headline,strkwidth, ymin,ymax,cbselecter,mapcolumn,mapdate,mapcountry,hourly,lines,avoidline,colorscale) 
{

	mouseover[gnumber] = []
	mouseover[gnumber].lenght = 0;	
	//show the buttons for the map if first div is a map
	if ((type == "map" ||type == "windmap")){
		 if (gnumber == "Graph1"){ 
			d3.select("#btnDiv").classed("hidden", false)
								.style.left= "+850px";}
		c = document.getElementById("Colours"); 
		if (c.value != "Standard"){colorscale = c.value}
		else {}
		
		if (type == "map"){
			d = document.getElementById("dataset");
			if (d.value == "PowerPrice")				{csv = "PowerPrices";	headline ="Power Price simulated in €/MWh" ;mapcolumn =4 ;}	
			else if (d.value == "Demand")				{csv = "Demand";		headline = "Demand in MW" ;					mapcolumn =1 ;}
			else if (d.value == "NetImports")			{csv = "NetImports";	headline = "NetImports in MW";				mapcolumn =2 ;}
			else if (d.value == "ResidualDemand")		{csv = "Demand";		headline = "Residual Demand in MWW";		mapcolumn =2 ;}
			else if (d.value == "Temperatur")			{csv = "Temperature";	headline = "Temperature in °C";				mapcolumn =2 ;}
			else if (d.value == "Nuclear Capacities")	{csv = "Capacities";	headline = "Nuclear Capacities in MW";		mapcolumn =1 ;}
			else if (d.value == "Lignite Capacities")	{csv = "Capacities";	headline = "Lignite Capacities in MW";		mapcolumn =2 ;}
			else if (d.value == "Hard Coal Capacities")	{csv = "Capacities";	headline = "Hard Coal Capacities in MW";	mapcolumn =3 ;}
			else if (d.value == "Gas Capacities")		{csv = "Capacities";	headline = "Gas Capacities in MW";			mapcolumn =4 ;}
			else if (d.value == "Oil Capacities")		{csv = "Capacities";	headline = "Oil Capacities in MW";			mapcolumn =5 ;}
			else if (d.value == "Bio Capacities")		{csv = "Capacities";	headline = "Bio Capacities in MW";			mapcolumn =6 ;}
			else if (d.value == "Reservoir Capacities")	{csv = "Capacities";	headline = "Reservoir Capacities in MW";	mapcolumn =7 ;}
			else if (d.value == "Pump Capacities")		{csv = "Capacities";	headline = "Pump Capacities in MW";			mapcolumn =8 ;}
			else if (d.value == "Hydro Capacities")		{csv = "Capacities";	headline = "Hydro Capacities in MW";		mapcolumn =9 ;}
			else if (d.value == "Wind Capacities")		{csv = "Capacities";	headline = "Wind Capacities in MW";			mapcolumn =10 ;}
			else if (d.value == "Solar Capacities")		{csv = "Capacities";	headline = "Solar Capacities in MW";		mapcolumn =11 ;}
			
			else {}
			crossbordercheck = document.getElementById("Crossborderflow");
			if (true === crossbordercheck.checked) {
				cbselecter = "1"
			}
		}
	}
	else if (gnumber == "Graph1"){ 
		d3.select("#btnDiv").classed("hidden", true);}

	
	z = document.getElementById("series");
	activetable = z.value
	
	if (activetable == "Compare"||activetable == "Compare-Maps"){
		if (gnumber == "Graph1"|| gnumber == "Graph3"  ||  gnumber == "Graph5"  ||  gnumber == "Graph7"  ||  gnumber == "Graph9" ||gnumber == "Graph11"){
		y = document.getElementById("szenario");
			datapath = y.value
		}
		else {
			y = document.getElementById("szenario2");
			datapath = y.value
			}
	}
	
		
	//allgemein
	//set the margins
	var margin = {top: 40, right: 150, bottom: 30, left: 60};
	if (type == "map"||type == "windmap"){var margin = {top: 0, right: 0, bottom: 0, left: 0};}

	//color function pulls from array of colors stored in colorscale
	color = []
	if (colorscale === undefined)
	{
		colorscale = []
		var color = d3.scale.ordinal().range(colorscale);
	}
	else
	{
		var color = d3.scale.ordinal().range(colorscale);
	}

	//define your year format here, first for the x csv input format, then if the date is displayed in tooltips, then for the x axis ticks
	Interval = InputEndDate-InputStartDate
	var parseDate = d3.time.format("%d.%m.%Y %H:%M").parse;
	var formatDate = d3.time.format("%d-%m-%Y %H:%M");
	if (rseries == "h" && Interval< 150000000) {axisformat = d3.time.format("%d-%m-%Y %H:%M");}  //bei weiger als 3 Tagen und einer stündlichen Auflösung werden die Stunden mit angeteigt
	else {axisformat = d3.time.format("%d-%m-%Y");}	
	var NumbType = d3.format(".2f");   // 2 Nachkommastellen 
	var NumbType1 = d3.format(".1f");   //1 Nachkommastelle 
	var NumbType0 = d3.format(".0f"); 

	//Legende: rect size: größe der Vierecke; spacing für Platz dazwischen
	legendRectSize = 14;
	legendSpacing = 4;

	//kein Rand um platzhalter container wenn es kein Graph gibt
	if (type == ""){d3.select("#"+gnumber).classed("hidden", true);}
	else {d3.select("#"+gnumber).classed("hidden", false);}
		
	//delete the old Graphs
	var div = document.getElementById(gnumber);	
	while(div.firstChild){
		div.removeChild(div.firstChild);
	}

	var width = +width- margin.left - margin.right;
	var height = +height- margin.top - margin.bottom;
	
	//erstellen des svg's
	var number = d3.select("#"+gnumber)
		.append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("id","svg"+gnumber)
		.attr("height", height + margin.top + margin.bottom)
		.append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	if (type == "map"||type == "windmap"){}
	else {
		number.append("text")            
			.attr("y", 4 - (margin.top / 2))
			.attr("x", width/2 )
			.style("font-size", "20px")  
			.style("font-family", typo) 
			.text(headline);	
	}									
	//make a rectangle so there is something to click on
	number.append("svg:rect")
		.attr("width", width)
		.attr("height", height)
		.style("stroke", "lightgrey")
		.style("stroke-width", 1)
		.attr("fill","white");
	
	//erstelle unterschiedliche Arten von Graphen 
////////////LINEGRAPH///////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	if (type == "line"|| type == "eu_line"|| type == "stackedline") 
	{
		 //make a clip path for the graph  (defines the visible area of thwe graph )
		var clip = number.append("svg:clipPath")
			.attr("id", "clip")
			.append("svg:rect")
			.attr("x", 0)
			.attr("y", 0)	
			.attr("width", width )
			.attr("height", height );  
			
		var f = document.getElementById("series");
		var seriesselect = f.options[f.selectedIndex].value;
		getyear = d3.time.format("%Y")
		getmonth = d3.time.format("%m")
		duobleload = 0;
		if (type == 'eu_line'){var series = "EU";}
		else {var series = mapcountry}
		if (rseries == "m" )		{parseDate = d3.time.format("%d.%m.%Y").parse; 			csvreso = datapath +"m"+csv + ".csv";												totiparse =  d3.time.format("%m.%Y")}
		else if (rseries == "y"  )	{parseDate = d3.time.format("%d.%m.%Y").parse; 			csvreso = datapath +"y"+csv + ".csv"; 												totiparse =  d3.time.format("%Y")}
		else if (rseries == "d"  )	{parseDate = d3.time.format("%d.%m.%Y").parse; 		if (type == 'eu_line'){ csvreso = datapath +"d"+csv + ".csv"; } else {	csvreso = datapath +"d"+csv +"_01-01-"+InputStartYear +".csv"}; 						totiparse =  d3.time.format("%d.%m.%Y")}
		else if (rseries == "h"  )	{
			if(hourly=="no"){
				parseDate = d3.time.format("%d.%m.%Y").parse; 			if (type == 'eu_line'){ csvreso = datapath +"d"+csv + ".csv"; } else {	csvreso = datapath +"d"+csv +"_01-01-"+InputStartYear +".csv"}; 						totiparse =  d3.time.format("%d.%m.%Y ")
			}
			else {
				parseDate = d3.time.format("%d.%m.%Y %H:%M:%S").parse; csvreso = datapath +"h"+csv +"_01-"+ InputStartMonthNr +"-"+InputStartYear +".csv" ;totiparse =  d3.time.format("%d.%m.%Y %H")
			}
		}
		

		
		//load the data...
		if (rseries == "d" && getyear(InputStartDate) < getyear(InputEndDate)){
			data = []
			strkwidth = 0.5
			imax = getyear(InputEndDate) - getyear(InputStartDate);
			q= queue()
			q.defer(d3.csv,csvreso) 
			for(i =1 ;i<= imax; i++){
				loadyear = +	getyear(InputStartDate) + i;
				csvresoi  =  datapath +"d"+csv +"_01-01-"+ loadyear +".csv"; 
				q.defer(d3.csv,csvresoi) 
			}
			q.awaitAll(function(error, datas) {
				if (datas == null ){nodataalert(number,hourly)}
				datas.forEach (function(entry) {data = data.concat(entry) });
				drwalinegraph(data)
			});
		}
			
		else if ((rseries == "h" && getyear(InputStartDate) < getyear(InputEndDate)) ||(rseries == "h" && getmonth(InputStartDate) < getmonth(InputEndDate)) ){
			if (hourly=="no"){}
			else{
				data = []
				strkwidth = 0.5
				yearcount = getyear(InputEndDate) - getyear(InputStartDate);
				monthcount = getmonth(InputEndDate) - getmonth(InputStartDate);
				stepcounter = +yearcount * 12 + monthcount
				
				loadyear = +	getyear(InputStartDate) ;
				loadmonth = +	getmonth(InputStartDate) ;				
				q= queue()
				q.defer(d3.csv,csvreso) 
				for(i =1 ;i<= stepcounter; i++){
					loadmonth = loadmonth +1
					if (loadmonth > 12)
					{
						loadmonth = 1
						loadyear = loadyear +1	
					}
					if (loadmonth > 9) {	csvresoi  =  datapath +"h"+csv +"_01-"+ loadmonth +"-"+ loadyear +".csv"; }
					else  {			csvresoi  =  datapath +"h"+csv +"_01-0"+ loadmonth +"-"+ loadyear +".csv"; }
					q.defer(d3.csv,csvresoi) 
				}
				q.awaitAll(function(error, datas) {
					if (datas == null ){nodataalert(number,hourly)}
					datas.forEach (function(entry) {data = data.concat(entry) });
					drwalinegraph(data)
				});
			}
		}
		
		
		else{
			queue()
				.defer(d3.csv,csvreso) 
				.await(function(error, data) {
				if (data == null ){nodataalert(number,hourly)}
			drwalinegraph(data)})
			;}


		function drwalinegraph(data)
		{
		//linien die laut stylesheet nicht geladen werden sollen werden nicht geladen	
		
			color.domain(d3.keys(data[0]).filter(function(key) { 
				keytext =  key !== "UTC" &&  key !== "Type" && key !==   avoidline[0]	&& key !==   avoidline[1]&& key !==   avoidline[2]&& key !==   avoidline[3]&& key !==   avoidline[4]&& key !==   avoidline[5]&& key !==   avoidline[6]&& key !==   avoidline[7]&& key !==   avoidline[8]&& key !==   avoidline[9]&& key !==   avoidline[10]&& key !==   avoidline[11]&& key !==   avoidline[12]&& key !==   avoidline[13]&& key !==   avoidline[14]&& key !==   avoidline[15]&& key !==   avoidline[16]&& key !==   avoidline[17]&& key !==   avoidline[18]&& key !==   avoidline[19];

	
				return (keytext) 
			}));
			
			//Linegraph

		if (type == "line"|| type == "eu_line") 
			{
				var x = d3.time.scale()
				var y = d3.scale.linear()
				var nested = d3.nest()
					.key(function(d) { return d.Type; })
					.map(data);
				
				// only retrieve data from the selected series, using the nest we just created
				var data = nested[series];

				// for object constancy we will need to set "keys", one for each type of data (column name) exclude all others.
				
				var linedata = color.domain().map(function(name) {

						return {name: name,
							values: data.map(function(d) {
							totidate = parseDate(d.UTC)
							totidate = totiparse(totidate)
							if (rseries == "h"){shownformat = totidate+":00"}
							else {shownformat = totidate}
							if (typeof mouseover[gnumber][totidate] === 'undefined'){mouseover[gnumber][totidate]= shownformat+"<br>"+ headline+": "+"<br>";}
								if (+d[name] != 0){mouseover[gnumber][totidate] = mouseover[gnumber][totidate] +"<br>"+name  +" : "+ NumbType1(+d[name])}
								return {name:name, date: parseDate(d.UTC), value: parseFloat(+d[name],10)};
							})
						};
					
				});
				if (rseries == "m" || rseries == "y"){interpolator = "step-after"}
				else {interpolator = "linear"}
				
				//will draw the line	
				
				var line = d3.svg.line()
					.x(function(d) { return x(d.date); })
					.y(function(d) { return y(d.value); });		
				line.interpolate(interpolator)					
				
				//bind the data
				var thegraph = number.selectAll(".thegraph")
					.data(linedata)
					
				//draw  a clip path
				var thegraphEnter=thegraph.enter().append("g")
					.attr("clip-path", "url(#clip)")
					.attr("class", "thegraph")
					.style("fill", "grey")
					.attr('id',function(d){ return headline + d.name+"-line"; })
					.style("stroke-width",5)

				//actually append the line to the graph
				thegraphEnter.append("path")
					.attr("class", "line")
					.style("stroke", function(d) { return color(d.name); })
					.style("stroke-width", strkwidth)
					.attr("d", function(d) { return line(d.values[0]); })
					.transition()
					.attrTween('d',function (d){
						var interpolate = d3.scale.quantile()
							.domain([0,1])
							.range(d3.range(1, d.values.length+1));
							return function(t){
							return line(d.values.slice(0, interpolate(t)));
						};
					})
				
				//setup the x and y scales
				//if (rseries == "h"  ){InputEndDatexline = InputEndDate.setHours(InputEndDate.getHours()+23) } // add 23 hours so the full day is displayed.
				//else {InputEndDatexline = InputEndDate}	
				InputEndDatexline = InputEndDate				
				// if no min and max values are given in the csv get them 
				minvalue = d3.min(linedata, function(c) { return d3.min(c.values, function(v) { return v.value; }); })
				if (minvalue < 0 && ymin=="auto"){ymin = minvalue * 1.1}
				else if (ymin=="auto"){ymin = 0};
				if (ymax=="auto"){ymax = d3.max(linedata, function(c) { return d3.max(c.values, function(v) { return v.value; })*1.1; })}	;	
			}	
//stackedline//////////////////////////////////////////////////////////////////////////////////////			
		else if (type == "stackedline") 
			{
				data.forEach(function(d) {	  
					d.UTC = parseDate(d.UTC);
				});
				// for object constancy we will need to set "keys", one for each type of data (column name) exclude all others.
			
				var x = d3.time.scale()
				var y = d3.scale.linear()
				if (rseries == "m" || rseries == "y"){interpolator = "step-after"}
				else {interpolator = "linear"}
				
				var area = d3.svg.area()
					.x(function(d) { return x(d.UTC); })
					.y0(function(d) { return y(d.y0); })
					.y1(function(d) { return y(d.y0 + d.y); })
					.interpolate(interpolator)	;
					
				var stack = d3.layout.stack()
					.values(function(d) { return d.values; });
					
				var nested = d3.nest()
					.key(function(d) { return d.Type; })
					.map(data);
				
				// only retrieve data from the selected series(country), using the nest we just created
				var data = nested[series];
				
				var browsers = stack(color.domain().map(function(name) {
					return {
						name: name,
						values: data.map(function(d) {
						return {UTC: (d.UTC), y:  parseFloat(+d[name],10)};
						})
					};
				}));
				
				var browser = number.selectAll(".browser")
					.data(browsers)
					.enter().append("g")
					.attr("clip-path", "url(#clip)")
					.attr("class", "browser")
					//.style("fill", "grey")
					.attr('id',function(d){ return headline + d.name+"-line"; }) // every line has an unique id: headline+linename+"line"
					//.style("stroke-width",5)

				
				browser.append("path")
					.attr("class", "area")
					.attr("d", function(d) { return area(d.values); })
					.style("fill", function(d) { return color(d.name); })
					.style("stroke", function(d) { return color(d.name); })
					.style("stroke-width", strkwidth)
					.transition()
					.attrTween('d',function (d){
						var interpolate = d3.scale.quantile()
							.domain([0,1])
							.range(d3.range(1, d.values.length+1));
							return function(t){
							return area(d.values.slice(0, interpolate(t)));
						};
					})
				//hier nur für die legede graph wird aus browsers erstellt			
				var linedata = color.domain().map(function(name) {
						return {name: name,
							values: data.map(function(d) {
							totidate = (d.UTC)
							totidate = totiparse(totidate)
							if (rseries == "h"){shownformat = totidate+":00"}
							else {shownformat = totidate}
							if (typeof mouseover[gnumber][totidate] == "undefined"){mouseover[gnumber][totidate]= shownformat+"<br>"+ headline+": "+"<br>";}
								if (+d[name] != 0){mouseover[gnumber][totidate] = mouseover[gnumber][totidate] +"<br>"+name  +" : "+ NumbType1(+d[name])}
								return {name:name, date: (d.UTC), value: parseFloat(+d[name],10)};
							})
						};
					
				});		
				InputEndDatexline = InputEndDate
				  // Find the value  with highest total value
				var maxUTCVal = d3.max(data, function(d){
					var vals = d3.keys(d).map(function(key){ return key !== "UTC" ? d[key] : 0 });
					return d3.sum(vals);
				});
				if (ymin=="auto"){ymin = 0};
				if (ymax=="auto"){ymax = maxUTCVal*1.1};		
			}
			
				x.domain([InputStartDate,InputEndDatexline])
				x.range([0, width]);
				//if (rseries == "h"  ){InputEndDatexline = InputEndDate.setHours(InputEndDate.getHours()-23)}  // to avoid the InputEndDate counts up we minus 23 h here again
			
			
				y.domain([ymin,ymax])
				y.range([height, 0]);
		
			//create and draw the x axis
			var xAxis = d3.svg.axis()
				.scale(x)
				.orient("bottom")
				.tickPadding(10)
				.tickSize(-height)
				.ticks(3)
				.tickFormat(axisformat);
				

					if (type == "stackedline"){ xAxis.tickSize(0)}
				
			number.append("g")
				.attr("class", "x axis")
				.attr("transform", "translate(0," + height + ")")
				.call(xAxis);

							
			//create and draw the y axis                  
			var yAxis = d3.svg.axis()
				.scale(y)
				.orient("left")
				.tickSize(-width)
				.ticks(4)
				.tickPadding(6);
				
				if (type == "stackedline"){ yAxis.tickSize(4)}
		
			number.append("g")
				.attr("class", "y axis")
				.call(yAxis);	
				
				
			//Buttons for Moving on x Axis
			move_button_right = number.append('text')
			  .attr("y", height+10)
			  .attr("x", width+50)
			  .attr("class", "clear-button")
			  .text(">>");
	  
			move_button_left = number.append('text')
			  .attr("y", height+10)
			  .attr("x", -50)
			  .attr("class", "clear-button")
			  .text("<<");	  
	  
			  move_button_right
			 .on('click', function(){vorzeichen ="1";movebutton(vorzeichen)});
			   move_button_left
			 .on('click', function(){vorzeichen ="-1";movebutton(vorzeichen)});
  
			//define the Legend
			//define here how many legend entrys should be maximum on a page using the height of the svg
			
						
			legperpage = Math.round(height/27)
            if(linedata.length > legperpage){

                legendPerPage=Math.ceil(legperpage);
                totalPages=Math.ceil(linedata.length/legendPerPage);

                pageNo=1;

                var startIndex=(pageNo-1)*legendPerPage;
                var endIndex=startIndex+legendPerPage;
                var seriesSubset=[],colorscaleubset=[];

                for(var i=0;i<linedata.length;i++){
                    if(i>=startIndex && i<endIndex){
                        seriesSubset.push(linedata[i]);
                        colorscaleubset.push(colorscale[i]);
                    }
                } 

                DrawLegendSubset(seriesSubset,colorscaleubset,legendPerPage,pageNo,totalPages,number);
            }
	else {
			var legend = number.selectAll('g.legend')
				.data(linedata)
				.enter()
				.append('g')
				.attr('class', 'legend')
				.attr('transform', function(d, i) {
					var height = legendRectSize + legendSpacing;
					var offset =  -10;
					var horz = width - offset;
					var vert = i * height - offset;
					return 'translate(' + horz + ',' + vert + ')';
				})
				.attr('id',function(d){ return headline +d.name; })
				//onclick function to toggle off the lines 
				.on('click', function (d) {                           			       	     	
					var elemented = document.getElementById(  this.id +"-line");   //grab the line that has the same ID as this point along w/ "-line"  use get element cause ID has spaces
					if(opp == 1){	
						d3.select(elemented)
							.transition()
							.duration(1000)
							.style("opacity",0)
							.style("display",'none');
						d3.select(this)
							.attr('fakeclass', 'fakelegend')
							.transition()
							.duration(1000)
							.style ("opacity", .2);
						opp = 0
					} 
					else if(opp == 0) {
						opp = 1
						d3.select(elemented)
							.style("display", "block")
							.transition()
							.duration(1000)
							.style("opacity",1);
						d3.select(this)
							.attr('fakeclass','legend')
							.transition()
							.duration(1000)
							.style ("opacity", 1);
					}
				});		  
			legend.append('rect')
				.attr('width', legendRectSize)
				.attr('height', legendRectSize)
				.attr('orient', "right")
				.style("fill", function(d, i) { return colorscale[i]; })
				
				  
			legend.append('text')
				.attr('x', legendRectSize + legendSpacing)
				.attr('y', legendRectSize - legendSpacing)
				.text(function(d){ return d.name; });
}
 function DrawLegendSubset(seriesSubset,colorscaleubset,legendPerPage,pageNo,totalPages){

                var legend = number.selectAll("g.legendg")
                .data(seriesSubset)
                .enter().append("g")
                .attr('class','legendg')
                .attr('transform', function(d, i) {
					var height = legendRectSize + legendSpacing;
					var offset =  -10;
					var horz = width - offset;
					var vert = i * height - offset;
					return 'translate(' + horz + ',' + vert + ')';
				}).attr('id',function(d){ return headline +d.name; })
				//onclick function to toggle off the lines 
				.on('click', function (d) {                           			       	     	
					var elemented = document.getElementById(  this.id +"-line");   //grab the line that has the same ID as this point along w/ "-line"  use get element cause ID has spaces
					if(opp == 1){	
						d3.select(elemented)
							.transition()
							.duration(1000)
							.style("opacity",0)
							.style("display",'none');
						d3.select(this)
							.attr('fakeclass', 'fakelegend')
							.transition()
							.duration(1000)
							.style ("opacity", .2);
						opp = 0
					} 
					else if(opp == 0) {
						opp = 1
						d3.select(elemented)
							.style("display", "block")
							.transition()
							.duration(1000)
							.style("opacity",1);
						d3.select(this)
							.attr('fakeclass','legend')
							.transition()
							.duration(1000)
							.style ("opacity", 1);
					}
				});	
				
				
                legend.append("rect")
                
                .attr("width", legendRectSize)
                .attr("height", legendRectSize)
                .attr("class", "legend")
				.attr('orient', "right")
                .style('fill',function(d,i){return colorscaleubset[i];})
               

			legend.append('text')
				.attr('x', legendRectSize + legendSpacing)
				.attr('y', legendRectSize - legendSpacing)
				.text(function(d){ return d.name; });


                var pageText = number.append("g")
                .attr('class','pageNo')
                .attr("transform", "translate(" + (width+7.5) + ","+ (legendPerPage+1)*(legendRectSize+legendSpacing) +")");

                pageText.append('text').text(pageNo+'/'+totalPages)
                .attr('dx','2.15em')
				.attr('dy','1.25em');

                var prevtriangle = number.append("g")
                .attr('class','prev')
                .attr("transform", "translate(" + (width+5) + ","+ (legendPerPage+1.5)*(legendRectSize+legendSpacing) +")")
                .on('click',prevLegend)
                .style('cursor','pointer');

                var nexttriangle = number.append("g")
                .attr('class','next')
                .attr("transform", "translate(" + (width+20) + ","+ (legendPerPage+1.5)*(legendRectSize+legendSpacing) +")")
                .on('click',nextLegend)
                .style('cursor','pointer');

                nexttriangle.append('polygon')
                    .style('stroke','#000')
                    .style('fill','#000')
                    .attr('points','0,0, 10,0, 5,5');

                prevtriangle.append('polygon')
                    .style('stroke','#000')
                    .style('fill','#000')
                    .attr('points','0,5, 10,5, 5,0');

                if(pageNo==totalPages){
                    nexttriangle.style('opacity','0.5')
                    nexttriangle.on('click','')
                    .style('cursor','');
                }
                else if(pageNo==1){
                    prevtriangle.style('opacity','0.5')
                    prevtriangle.on('click','')
                    .style('cursor','');
                }

            }

            function prevLegend(){
                pageNo--;

                number.selectAll("g.legendg").remove();
                number.select('.pageNo').remove();
                number.select('.prev').remove();
                number.select('.next').remove();

                var startIndex=(pageNo-1)*legendPerPage;
                var endIndex=startIndex+legendPerPage;

                var seriesSubset=[],colorscaleubset=[];

                for(var i=0;i<linedata.length;i++){
                    if(i>=startIndex && i<endIndex){
                        seriesSubset.push(linedata[i]);
                        colorscaleubset.push(colorscale[i]);
                    }
                }  

                DrawLegendSubset(seriesSubset,colorscaleubset,legendPerPage,pageNo,totalPages);
            }
            
            function nextLegend(){
                pageNo++;

                number.selectAll("g.legendg").remove();
                number.select('.pageNo').remove();
                number.select('.prev').remove();
                number.select('.next').remove();

                var startIndex=(pageNo-1)*legendPerPage;
                var endIndex=startIndex+legendPerPage;

                var seriesSubset=[],colorscaleubset=[];

                for(var i=0;i<linedata.length;i++){
                    if(i>=startIndex && i<endIndex){
                        seriesSubset.push(linedata[i]);
                        colorscaleubset.push(colorscale[i]);
                    }
                }  

               DrawLegendSubset(seriesSubset,colorscaleubset,legendPerPage,pageNo,totalPages);
            }


	
			
			//define the brush	
			var brush = d3.svg.brush()
				.x(x)
				.on("brushend",brushed);
				
			number.append("g")
				.attr("class", "x brush")
				.call(brush)
				.selectAll("rect")
				.attr("y", 0)
				.attr("height", height );

			function brushed() {
				tooltip.classed("hidden", true);
				var regex = /(.+),(.+)/ ;
				match = regex.exec(brush.extent());
				startd = match[1] ;
				endd =  match[2] ;
				if (startd == endd) {mapdate = new Date(startd); selecteddate = mapdate; change(mapdate,mapcountry) ;return;} // change mapdate on one click
				brushselect(startd,endd)
			}


			//define the Tooltips/Mousovers
			ttipid = "#tooltip" + gnumber;
			tooltip = d3.select(ttipid)
			.attr("class", "tooltip hidden")
	
			
			number.selectAll("rect")
				.on("mousemove", function(d) {
					var mousel = d3.event.pageX;
					var mouset = d3.event.pageY;
					var x0 = x.invert(d3.mouse(this)[0])
					var y0 = y.invert(d3.mouse(this)[1])
					getmouseposition(x0,y0,mousel,mouset)
					//alert(mousel)

					totidate = totiparse(x0)
					tooltip.classed("hidden", false)
						.attr("style", "left:"+(ttposition)+"px;top:"+(ttheight)+"px")
						.html(mouseover[gnumber][(totidate)]);
						//.html("Date: "+formatDate(x0) + "<br>" + d.name + ": "+ NumbType(y0) );
				})
				.on("mouseout",  function(d) {
					tooltip.classed("hidden", true);
				}) 
				.on("mousedown", function(){
					if(d3.event.button === 2){
						d3.event.stopImmediatePropagation();		//verhindert das mit rechter maustaste "gebrushed" wird
					};
				})
				.on('contextmenu', function (d, i) {				// react on right-clicking
					tooltip.classed("hidden", true);
					d3.event.preventDefault();
					showall()
				});

		}		
	}	
	

/////////Map with countries and Crossborderflow//////////////////////////////////////////////////////////////////////////////////////////	
	else {if (type == "map") 
	{	
	
		maxcosc = document.getElementById("maxcosc").value;
		mincosc = document.getElementById("mincosc").value;
		if (maxcosc != ""){ymax = maxcosc}
		if (mincosc != ""){ymin = mincosc}
		//zoom and center settings for diffrent countrys
		land = mapcountry		
		centercountry(land)
		setup(width,height);		
		zoom = d3.behavior.zoom()
			.scaleExtent([1,2.5])
			//.center([(tran1), (tran2)])
			.scale( sca+(height + margin.top + margin.bottom-300)*1.5)		
			.on("zoom", move);
		//call the zoom on the SVG
		number.call(zoom)
		//load the data from CSV
		if (rseries == "y"){dateparser = d3.time.format("%Y")}
		else if (rseries == "m"){dateparser = d3.time.format("%Y-%m")}
		else if (rseries == "d"){dateparser = d3.time.format("%Y-%m-%d")}
		else if (rseries == "h"){dateparser = d3.time.format("%d-%m-%Y %H")}
		ccoulour = new Array;
		coulour = new Array;
		cvalue = new Array;
		var data =  new Array;
		mapdateparser = d3.time.format("%d-%m-%Y %H:%M");
		if (rseries == "m" )		{parseDate = d3.time.format("%d.%m.%Y").parse; 			csvreso = datapath +"m"+csv + ".csv"		;											mintinterval = 1332800000	}
		else if (rseries == "y"  )	{parseDate = d3.time.format("%d.%m.%Y").parse; 			csvreso = datapath +"y"+csv + ".csv" 		;											mintinterval = 1332800000}
		else if (rseries == "d"  )	{parseDate = d3.time.format("%d.%m.%Y").parse; 			csvreso = datapath +"d"+csv +"_01-01-"+MapYear +".csv" 	;						mintinterval = 86400000}
		else if (rseries == "h"  )	{
			if(hourly=="no"){
				parseDate = d3.time.format("%d.%m.%Y").parse; 			csvreso = datapath +"d"+csv +"_01-01-"+MapYear +".csv" 	;						mintinterval = 86400000}
			else{
				parseDate = d3.time.format("%d.%m.%Y %H:%M:%S").parse; csvreso = datapath +"h"+csv +"_01-"+ InputStartMonthNr +"-"+InputStartYear +".csv" ;	mintinterval = 3600000}
		}
	
		cbflowsparseDate = d3.time.format("%d.%m.%Y %H:%M").parse;
		getyear = d3.time.format("%Y")
		getmonth = d3.time.format("%m")


		queue()
			.defer(d3.csv,csvreso) 
			.await(function(error, data) {
			if (data == null ){nodataalert(number,hourly)}
				load(data)
			})
		

		ttipid = "#tooltip" + gnumber;
		tooltip = d3.select(ttipid).attr("class", "tooltip hidden");

		// legende
		//array of  colours for scale 
		for (var i = 1; i <= 11; i++)
		{
			n= i/10;
			getcolours(n,colorscale)
			coulour[i] =colour;
		}	
		varcolour = [coulour[1],coulour[2],coulour[3],coulour[4],coulour[5],coulour[6],coulour[7],coulour[8],coulour[9],coulour[10],coulour[11]]
		
		var threshold = d3.scale.threshold()
			.domain(d3.range(5,16))
			.range(varcolour)

		var x = d3.scale.linear()
			.domain([1,5,11])
			.range([20, 90])	
			
		var xAxis = d3.svg.axis() 
			.scale(x)
			.tickSize(100)	
			.tickValues(d3.range(1.5,12.5,5))	
			.tickFormat(function(d)  {ymin = +ymin;return  (((ymax-ymin)/10)*(d-1.5)+ymin); }) 

		var legend = d3.select("#svg"+gnumber)		
			
		var headpts = "0,0 0,130 "+width+",130 "+width+",0";
		maphead = legend.append("svg:polygon")
			.attr("points", headpts)
			.attr("stroke", "lightgrey")
			.attr("stroke-width", 1)
			.attr("fill", "white");

		legend
			.style("font-size","16px")
			//.attr('transform', 'translate(0, 0)')
			.call(xAxis);		
				
		legend.select(".domain")
			.remove();
			
		legend.selectAll("rect")
			.data(threshold.range().map(function(color) {
				var d = threshold.invertExtent(color);
				if (d[0] == null) d[0] = x.domain()[0];
				if (d[1] == null) d[1] = x.domain()[1];
				return d;
			}))
			.enter().insert("rect", ".tick")
			.attr("height", 12)
			.attr("y", 85)
			.attr("x", function(d) { return x(d[0])-60; })
			.attr("width", function(d) { return x(d[1]) - x(d[0]); })
			//.attr("transform", function(d) { return "rotate(90)" })
			.attr("fill", function(d) { return threshold(d[0]); })
			
		legend.append("text")
			.attr("fill", "#000")
			.attr("font-weight", "bold")
			.attr("text-anchor", "start")
			.attr("y", 26)
			.attr("x", 6)
			.style("font-size","22px")
			.style("font-family", typo) 
			.text(headline);

		if (rseries == "h"){shownformat = dateparser(mapdate)+":00"}
		else {shownformat = dateparser(mapdate)}
		legend.append("text")
			.attr("fill", "#000")
			//.attr("font-weight", "bold")
			.attr("text-anchor", "start")
			.attr("y", 60)
			.attr("x", 6)
			.style("font-size","18px")
			.style("font-family", typo) 
			.text("Date: "+shownformat);
		
/////Functions		
		function setup(width,height){
			//projection = d3.geo.mercator()
			if (width > 600){
			projection =d3.geo.naturalEarth()
				.translate([(tran1+(height + margin.top + margin.bottom-300)), (tran2+(height + margin.top + margin.bottom-300)*2)])				//ganz europa bei einer höhe von 300px: 75,470 scale 350
				.scale( sca+(height + margin.top + margin.bottom-300)*1.5);																			//Zoomstufe (kleinere Zahl --> weniger Zooom)
			}
			else {
			projection =d3.geo.naturalEarth()
				.translate([(tran1+(height + margin.top + margin.bottom-300)*1.8), (tran2+(height + margin.top + margin.bottom-300)*2)])				//ganz europa bei einer höhe von 300px: 75,470 scale 350
				.scale( sca+(height + margin.top + margin.bottom-300)*1.5);																			//Zoomstufe (kleinere Zahl --> weniger Zooom)
			}
			path = d3.geo.path().projection(projection)		 
		}
		//Zoomfunktion
		function move() {
			var t = d3.event.translate;
			s = d3.event.scale; 
			var coordinates = [0, 0];
			coordinates = d3.mouse(this);
			var mx = coordinates[0];
			var my = coordinates[1];
			//s>1 bei aktivem zoom mit my/mx wird auf die mausposition gezoomt bei s=1 (maximales herauszoomen ist ganz europa sichtbar
			if(s>1){
				t[0] = (1-s)*mx;
				t[1] = (1-s)*my;
			}
			else {
				t[0] = (1-s)*650;
				t[1] = (1-s)*750;
			}

			zoom.translate(t);
			
			number.attr("transform", "translate(" + t + ")scale(" + s + ")");
		  d3.selectAll(".text").style("opacity",   2.5*s-2.84);	//ab einen s Wert von 0.9 wird Text unsichtbar
		}
		
		function load(data){
					causes =[];
			var header = d3.keys(data[1]);		//Spalte der Länder
			
			for (i=1;i<header.length;i++){causes[i-1]= header[i];}
			
			line = causes[mapcolumn];   //Spaltennummer aus der die Werte kommen sollen	
			autoscalemax = "init";	
			autoscalemin = "init";	
		
					
			data.forEach(function(i){
				i.UTC = parseDate(i.UTC);
				if (rseries == "y"){dateparser = d3.time.format("%Y")}
				if (rseries == "m"){dateparser = d3.time.format("%Y-%m")}
				if (rseries == "d"){dateparser = d3.time.format("%Y-%m-%d")}
				if (rseries == "h"){
					if(hourly=="no"){dateparser = d3.time.format("%Y-%m-%d")}
					else {
						dateparser = d3.time.format("%Y-%m-%d %H")}
				}
				//i.UTC = dateparser(i.UTC)
				//cmapdate = dateparser(mapdate)
				tinterval = mapdate-i.UTC
				
				//mapstartdate = mapdateparser(mapdate)
				
				test = showncountries.indexOf(i.Type);
				if (test>=0){
					if (dateparser(mapdate) == dateparser(i.UTC)){
						getminmax(i[line])

						getcolour(i.Type,i[line]);						//Type ist die Spalte mit den Ländernamen
					}
				}	
			});	
			//Autoscale the map
			if (autoscalevalue ==1 && firsttimehere == 0){
				autoscalemin = +autoscalemin
				autoscalemax = +autoscalemax
				autoscalemin = autoscalemin.toFixed(0);  //runden
				autoscalemax = autoscalemax.toFixed(0);
				e = document.getElementById("mincosc");
				e.value = autoscalemin;
				f = document.getElementById("maxcosc");
				f.value = autoscalemax;
				firsttimehere = 1;
				addplot(gnumber, width, height, type, csv, headline,strkwidth, ymin,ymax,cbselecter,mapcolumn,mapdate,mapcountry,hourly,lines,avoidline,colorscale) 
			}
			else {firsttimehere = 0;}
			d3.json("libarys/world-topo-min.json", function(error, world) {
				var topo = topojson.feature(world, world.objects.countries).features;	
				draw(topo,ccoulour);
			});
		//adding some crossborderflows from external CSV file if selecter is set to 1 in stylesheets
			if(cbselecter == 1)
			{
				loadvalues()
			}
			else {}
			
		};	

function loadvalues(){
			cexport = []; 
			cimport = []; 
			if (rseries == "m" )		{parseDate = d3.time.format("%d.%m.%Y").parse; 			cbdata = datapath +"mCBCaps.csv"}
			else if (rseries == "y"  )	{parseDate = d3.time.format("%d.%m.%Y").parse; 			cbdata = datapath +"yCBCaps.csv" }
			else if (rseries == "d"  )	{parseDate = d3.time.format("%d.%m.%Y").parse; 			cbdata = datapath +"dCBCaps" +"_01-01-"+InputStartYear +".csv" }
			else if (rseries == "h"  )	{parseDate = d3.time.format("%d.%m.%Y %H:%M:%S").parse; cbdata = datapath +"hCBCaps" +"_01-"+ InputStartMonthNr +"-"+InputStartYear +".csv" ;}

			if (rseries == "d" && getyear(InputStartDate) < getyear(InputEndDate)){ 	cbdata2 =  datapath +"dCBCaps" +"_01-01-"+getyear(InputEndDate) +".csv"; 					duobleload = 1;}
			if (rseries == "h" && getmonth(InputStartDate) < getmonth(InputEndDate)){ 	cbdata2 =  datapath +"hCBCaps" +"_01-"+ getmonth(InputEndDate) +"-"+InputStartYear +".csv"; 	duobleload = 1;}
			if (rseries == "h" && getyear(InputStartDate) < getyear(InputEndDate)){ 	cbdata2 =  datapath +"hCBCaps" +"_01-01-"+getyear(InputEndDate) +".csv"; 					duobleload = 1;}
		
			if (duobleload ==1){
				queue()
					.defer(d3.csv,cbdata) 
					.defer(d3.csv,cbdata2) 
					.await(function(error, data1, data2) {
						flowvalue = data1.concat(data2) 
						loadflowvalues(flowvalue)
					})
			}
			else{
				queue()
					.defer(d3.csv,cbdata) 
					.await(function(error, flowvalue) {
						loadflowvalues(flowvalue)
					})
			}
			
			function loadflowvalues(flowvalue){				
				flowvalue.forEach(function(i){
					i.utc = parseDate(i.UTC);
					i.type = i.Type;
					var regex = /(\w+)>(\w+)/ ;
					match = regex.exec(i.type);
					i.scene = match[1] ;
					i.level =  match[2] ;
					InputStartDate = InputDateParse(fromdate);
					if (rseries == "y"){dateparser = d3.time.format("%Y")}
					if (rseries == "m"){dateparser = d3.time.format("%Y-%m")}
					if (rseries == "d"){dateparser = d3.time.format("%Y-%m-%d")}
					if (rseries == "h"){dateparser = d3.time.format("%Y-%m-%d %H")}
					Interval =i.utc-mapdate
					
					if ( i.scene == shortname  && dateparser(i.utc) == dateparser(mapdate)){  
						cexport[i.level] = i.applied;
					}
					else if ( i.level == shortname  && dateparser(i.utc) == dateparser(mapdate)){  
						cimport[i.scene] = i.applied;
					}
				});	
				getlatlon();
			};	
		}	
		
		function getlatlon(){
			textval = []; 
			textval2 = [];
			direction = [];
			d3.csv("libarys/crossborder.csv", function(err, cbflows) {
				cbflows.forEach(function(i){
					i.value = i.value;
					var regex2 = /(\w+)-(\w+)/ ;
					match2 = regex2.exec(i.value);
					i.fcountry = match2[1] ;
					i.tcountry =  match2[2] ;
					if ( i.fcountry == shortname){ 
						exvalue = cexport[i.tcountry]
						imvalue = cimport[i.tcountry]
						addpoint(i.value, i.Longitude1, i.Latitude1,i.Longitude2, i.Latitude2,i.country1,i.country2,exvalue,imvalue);
					}
					if ( i.tcountry == shortname){ 
						exvalue = cimport[i.fcountry]
						imvalue = cexport[i.fcountry]
						addpoint(i.value, i.Longitude1, i.Latitude1,i.Longitude2, i.Latitude2,i.country1,i.country2,exvalue,imvalue);
					}
				});
			});
		}
		
				//function to add polygons and text to the map 
		function addpoint(text,lat1,lon1,lat2,lon2,country1,country2,exvalaue,imvalue) {
				textval2[text] = imvalue
				textval[text] = exvalue
				vorzeichen = 1
				direction[text] = + textval[text] - textval2[text];
			if (+direction[text] < 0){latzw = lat2; lonzw = lon2 ; lat2 = lat1; lon2 = lon1; lat1 = latzw ; lon1 = lonzw; vorzeichen = -1	}
			//var size = 5; // Dicke der Pfeile
			var size = +direction[text]  / 350;   // Dicke der Pfeile
			if (size > 5){size =5}
			if (size < 1.5){size =1.5}
			var gpoint = number.append("svg")
				.attr("class", "gpoint");
				
			if (+lat2 < +lat1 || +lon2 > +lon1){var pfeil = -size;}
			else  {var pfeil = size;}
			
			var x1 = projection([lat1,lon1])[0];
			var y1 = projection([lat1,lon1])[1];
			var x2 = projection([lat2,lon2])[0];
			var y2 = projection([lat2,lon2])[1];
			if(lat1==lat2)	{var p1x = x1 + pfeil; 	var p1y = y1; 		var p2x = x1 + pfeil; 		var p2y = y2 -2*pfeil; 	var p3x = x1 + 2*pfeil; 	var p3y = y2 -2*pfeil;	var p4x = x1 ; 	var p4y = y2 ;	var p5x = x1 -2* pfeil; 	var p5y = y2 -2*pfeil; 	var p6x = x1 - pfeil; 		var p6y = y2 -2*pfeil;	var p7x = x1 - pfeil; 	var p7y = y1;}
			else 		{var p1x = x1 ; 		var p1y = y1+pfeil; var p2x = x2 - 2*pfeil; 	var p2y = y2 + pfeil; 	var p3x = x2 - 2*pfeil; 	var p3y = y2 +2*pfeil;	var p4x = x2 ; 	var p4y = y2 ;	var p5x = x2 -2* pfeil; 	var p5y = y2 -2*pfeil;	var p6x = x2 - 2*pfeil; 	var p6y = y2 - pfeil;	var p7x = x1 ; 			var p7y = y1 - pfeil;}
			var pts = p1x+","+p1y+" "+p2x+","+p2y+" "+p3x+","+p3y+" "+p4x+","+p4y+" "+p5x+","+p5y+" "+p6x+","+p6y+" "+p7x+","+p7y;			
			var xt = x2;
			var yt = y2;
			if (x1 > x2){var xt = x1;}
			gpoint.append("svg:polygon")
				.attr("points", pts)
				.attr("fill", "darkblue");

			netto = NumbType1(+direction[text] * vorzeichen)
			if (!isNaN(netto)){
				gpoint.append("text")
					.attr("x", xt+5)
					.attr("y", yt+6)
					.style("opacity",0)
					.attr("class","text")
					.attr("fill", "black")
					.text(netto+"MW");
			  }
			//offsets for tooltips2(cbflows)
			var offsetL = 20;
			var offsetT = 20;  
				  
			//tooltips2
			gpoint
				.on("mousemove", function(d,i) {
					tooltip.classed("hidden", false)
						.attr("style", 'left:' + (d3.event.clientX + offsetL) + 'px; top:' + (d3.event.clientY - offsetT) + 'px')
						.html( country1+" to "+country2+": "+NumbType1(textval[text])+"  MW<br>"+country2+" to "+country1+": "+NumbType1(textval2[text])+"  MW");
				})
				.on("mouseout",  function(d,i) {
					tooltip.classed("hidden", true);
				}); 
		}
function getminmax(value)	
{
value = +value
if (autoscalemax == "init"){autoscalemax = +value}
			if (autoscalemin == "init"){autoscalemin = +value}
			if (value >= autoscalemax){autoscalemax = value}
			if (value <= autoscalemin){autoscalemin = value;}
			

}
		//Berechnungsvorschriften um aus Werten eine Farbe zu machen kommen hier hin
		function getcolour(country,value) {

			ymax = +ymax;
			n = (+value-ymin)	/(ymax-ymin);
			value = +value
			if (n < 0){n = 0; }
			if (n > 1){n = 1; }	
			getcolours(n,colorscale)
			
			
			ccoulour[country] = colour;
			cvalue[country] = value;
		}
		
		function draw(topo,ccoulour) {
			var country = number.selectAll(".type").data(topo);
			country.enter().insert("path")
				.attr("class", "country")
				.attr("d", path)
				.attr("id", function(d) { return d.id; })
				.attr("title", function(d) { return d.properties.name; })
				//farbe
				.style("fill", function(d,i) { contry = (ccoulour[d.properties.name]) ; 
					if ( typeof ccoulour[d.properties.name] != 'undefined') {;d.properties.color = contry;return d.properties.color}
					else {d.properties.color = "lightgrey" ;return d.properties.color}
				});

			
			//offsets for tooltips(countries)
			var offsetL = 20;
			var offsetT = 20;  

			//tooltips for countries
			 country
				.on("mousemove", function(d,i) {
				  tooltip.classed("hidden", false)
						 .attr("style", 'left:' + (d3.event.clientX + offsetL) + 'px; top:' + (d3.event.clientY - offsetT) + 'px')
						 .html(d.properties.name+ "<br> "+headline+" : "+ NumbType(cvalue[d.properties.name]));
				  })
				  .on("mouseout",  function(d,i) {
					tooltip.classed("hidden", true);
				  })
				.on("click", function(d) {
					tooltip.classed("hidden", true);
					e = document.getElementById("cntry");
					e.value = d.properties.name
					change(mapdate,d.properties.name)
				});	
					mapfontsize = "15px";
				country.enter().insert("text")
					.attr("class", "country-label")
					.attr("transform", function(d) {
						if( path.centroid(d) != 'NaN,NaN') {	
							return "translate(" +  path.centroid(d) + ")"; 
						}
					})		//use the geographic middle of the countries(sometimes a offset is necesary(defined in centersettings at the beginning)
					.text(function(d) { return d.properties.sname ; })
					.attr("dx", function (d) {
						centercountry(d.properties.name);
						clatvalue = -0.2+clat
						return clatvalue+"em";
                    })
                    .attr("dy", function (d) {
                        centercountry(d.properties.name);
						clonvalue = -0.9+clon
						return clonvalue+"em";
                    })
                    .style('fill', 'black')
					.style("font-size",mapfontsize)
					.attr("font-weight", "bold")
					.style("font-family", typo) 
					.on("click", function(d) {
						tooltip.classed("hidden", true);
						e = document.getElementById("cntry");
						e.value = d.properties.name
						change(mapdate,d.properties.name)
					});	
			
				country.enter().insert("text")
					.attr("class", "country-val")
					.attr("transform", function(d) {
						if( path.centroid(d) != 'NaN,NaN') {	
							return "translate(" +  path.centroid(d) + ")"; 
						}
					})	
					.text(function(d) {if(!isNaN(cvalue[d.properties.name])){
						if (ymax >= 1000 || ymin <= -1000){return NumbType0(cvalue[d.properties.name])}
						else{ return NumbType(cvalue[d.properties.name]) ;} 
					}})
					.attr("dx", function (d) {
						centercountry(d.properties.name);
						clatvalue = -0.8+clat
						return clatvalue+"em";
                    })
                    .attr("dy", function (d) {
                        centercountry(d.properties.name);
						clonvalue = -0.02 + clon
						return clonvalue+"em";
                    })
                    .style('fill', 'black')
					.style("font-size",mapfontsize)
					.style("font-family", typo) 
						.on("click", function(d) {
					tooltip.classed("hidden", true);
					e = document.getElementById("cntry");
					e.value = d.properties.name
					change(mapdate,d.properties.name)
				});	
				land = mapcountry
		centercountry(land)
		}
		
	}
	
	
	
	
//////////////////WINDMAP,TEMPERATUTMAP,RADIATIONMAP///////////////////////////////////////////////////////////////	
	else {if (type == "windmap") {
	autoscalemax = "init";	
			autoscalemin = "init";	
		maxcosc = document.getElementById("maxcosc").value;
		mincosc = document.getElementById("mincosc").value;
		if (maxcosc != ""){ymax = maxcosc}
		if (mincosc != ""){ymin = mincosc}
		InputYearParse = d3.time.format("%Y");
		InputMonthParse = d3.time.format("%m");
		InputDayParse = d3.time.format("%d");
		mapdateyear = InputYearParse(mapdate);
		mapdatemonth = InputMonthParse(mapdate);
		mapdateday = InputDayParse(mapdate);


		stylecsv = document.getElementById("series").value;
		land = mapcountry;; concolor = "white";concolorop = 0
		if (csv == "winddata.csv"){mapdateparser = d3.time.format("%Y"); dateparser = d3.time.format("%Y")}
		else{
			
			if (rseries == "y" )		{mapdateparser = d3.time.format("%Y"); 					csv = "y"+csv + ".csv"		;											dateparser = d3.time.format("%Y")	}
			else if (rseries == "m"  )	{mapdateparser = d3.time.format("01.%m.%Y"); 			csv = "m"+csv +"_"+mapdateyear +".csv" 		;											dateparser = d3.time.format("%Y-%m")}
			else if (rseries == "d"  )	{mapdateparser = d3.time.format("%d.%m.%Y"); 			csv = "d"+csv +"_01-"+mapdatemonth+"-"+mapdateyear +".csv" 	;						dateparser = d3.time.format("%Y-%m-%d")}
			else if (rseries == "h"  )	{
				if(hourly=="no"){mapdateparser = d3.time.format("%d.%m.%Y"); 			csv = "d"+csv +"_01-"+mapdatemonth+"-"+mapdateyear +".csv" 	;						dateparser = d3.time.format("%Y-%m-%d")}
				else {
					mapdateparser = d3.time.format("%d.%m.%Y %H:00:00"); 	csv = "h"+csv +"_"+mapdateday+"-"+mapdatemonth+"-"+mapdateyear +".csv" 	; ;	dateparser = d3.time.format("%d-%m-%Y %H")}
			}		
		}

		
		
		centercountry(land)
		setup(width,height);


		zoom = d3.behavior.zoom()
			.scaleExtent([1,2.5])
			.center([(tran1), (tran2)])
			.scale( sca+(height + margin.top + margin.bottom-300)*1.5)		
			.on("zoom", move);
			
		//call the zoom on the SVG
		number.call(zoom)
		
		function move() {
			var t = d3.event.translate;
			s = d3.event.scale; 
			var coordinates = [0, 0];
			coordinates = d3.mouse(this);
			var mx = coordinates[0];
			var my = coordinates[1];
			//s>1 bei aktivem zoom mit my/mx wird auf die mausposition gezoomt bei s=1 (maximales herauszoomen ist ganz europa sichtbar
			if(s>1){
				t[0] = (1-s)*mx;
				t[1] = (1-s)*my;
			}
			else {
				t[0] = (1-s)*650;
				t[1] = (1-s)*750;
			}

			zoom.translate(t);
			
			number.attr("transform", "translate(" + t + ")scale(" + s + ")");
		  d3.selectAll(".text").style("opacity",   2.5*s-2.84);	//ab einen s Wert von 0.9 wird Text unsichtbar
		}
		
		

					//adding some data from external CSV file
			wdata = meteodatapath + csv
			comparedate = mapdateparser(mapdate);
						//comparedate = mapdateparser(comparedate);

			
			d3.csv(wdata, function(err, value) {
				value.forEach(function(i){
	
				if (csv == "winddata.csv"){
					comparedate = mapdateparser(mapdate);
					
					if (i.Date == comparedate){
							addpoint(i.LON, i.Latitude,i.value );
						}
					}
					
					else {
						
						colname = comparedate;
						getminmax(i[colname])
						if (autoscalevalue ==0)
							{addpoint(i.LON, i.LAT,i[colname] );}
						if (autoscalevalue ==1 && firsttimehere == 1)
							{addpoint(i.LON, i.LAT,i[colname] );}	
					}
					
				});
				
				if (autoscalevalue ==1 && firsttimehere == 0){
				autoscalemin = +autoscalemin
				autoscalemax = +autoscalemax
				autoscalemin = autoscalemin.toFixed(0);
				autoscalemax = autoscalemax.toFixed(0);
				e = document.getElementById("mincosc");
				e.value = autoscalemin;
				f = document.getElementById("maxcosc");
				f.value = autoscalemax;
				firsttimehere = 1;
				change(mapdate,mapcountry)
				}
				else {firsttimehere = 0;}
				
				d3.json("libarys/world-topo-min.json", function(error, world) {
					var topo = topojson.feature(world, world.objects.countries).features;
						draw(topo);
				});	
			});
		

				
		ttipid = "#tooltip" + gnumber;
			tooltip = d3.select(ttipid).attr("class", "tooltip hidden");
		function draw(topo) {
			var country = number.selectAll(".type").data(topo);
			country.enter().insert("path")
				.attr("class", "country")
				.attr("d", path)
				.attr("id", function(d,i) { return d.id; })
				.attr("title", function(d,i) { return d.properties.name; })
				//farbe
				.style("fill", concolor)
				.attr("fill-opacity",concolorop)
				
			//offsets for tooltips
			var offsetL = 20;
			var offsetT = 20;  

			//tooltips for countries
			 country	
				.on("click", function(d) {
					tooltip.classed("hidden", true);
					e = document.getElementById("cntry");
					e.value = d.properties.name
					change(mapdate,d.properties.name)
				});				 
		}
	

	
		coulour = new Array;		
		ymax = +ymax;
		ymin = +ymin	

	function getminmax(value)	
{
value = +value
if (autoscalemax == "init"){autoscalemax = +value}
			if (autoscalemin == "init"){autoscalemin = +value}
			if (value >= autoscalemax){autoscalemax = value}
			if (value <= autoscalemin){autoscalemin = value;}
			

}	
				
		function addpoint(lat,lon,value) {
			auflsng =0.5
			var lat1 = +lat-auflsng/2;
			var lon1 = +lon-auflsng/2;
			var lat2 = +lat+auflsng/2;
			var lon2 = +lon+auflsng/2;
			var gpoint = number.append("g").attr("class", "gpoint");
			var x = projection([lat1,lon1])[0];
			var y = projection([lat1,lon1])[1];
			var x2 = projection([lat2,lon2])[0]*1.0051;
			var y2 = projection([lat2,lon2])[1]-0.55;
			value = +value
			n = (+value-ymin)	/(ymax-ymin);

			getcolours(n,colorscale)
					

polypoints = x+","+y+"  "+x2+","+y+" "+x2+","+y2+" "+x+","+y2+" "

gpoint.append("polygon")
.attr("points",polypoints)
.attr("fill-opacity",oppcity)
.attr("stroke-width", "0px")
.attr("stroke", colour)
.attr("fill", colour);
		
			//offsets for tooltips
			var offsetL = 0;
			var offsetT = 100;
			var ttvalue = (Math.round(+value*100))/100;			  
				  
			//tooltips
			//gpoint
				//.on("mousemove", function(d,i) {
			//tooltip.classed("hidden", false)
						//.attr("style", 'left:' + (d3.event.clientX + offsetL) + 'px; top:' + (d3.event.clientY - offsetT) + 'px')
						//.html( headline+": "+ttvalue);
				//})
				//.on("mouseout",  function(d,i) {
				//	tooltip.classed("hidden", true);
			//	});		
		}
		// legende
		
		//array of  colours for scale 
		
		
			for (var i = 0; i <= 10; i++){
				n= i/10;
				getcolours(n,colorscale)
				coulour[i] =colour;
				
			}
		
		varcolour = [coulour[0],coulour[1],coulour[2],coulour[3],coulour[4],coulour[5],coulour[6],coulour[7],coulour[8],coulour[9],coulour[10]]
			

var threshold = d3.scale.threshold()
			.domain(d3.range(5,16))
			.range(varcolour)

		var x = d3.scale.linear()
			.domain([1,5,11])
			.range([0, 90])	
			
		
		var xAxis = d3.svg.axis()  

			.scale(x)
			
			.tickSize(100)	
			.tickValues(d3.range(1.5,12.5,5))	
			.tickFormat(function(d)  {ymin = +ymin;return  (((ymax-ymin)/10)*(d-1.5)+ymin); }) 
				
		 legend = d3.select("#svg"+gnumber)
		 
		 			var headpts = "0,0 0,130 "+width+",130 "+width+",0";
			maphead = legend.append("svg:polygon")
				.attr("points", headpts)
				.attr("stroke", "lightgrey")
				.attr("stroke-width", 1)
				.attr("fill", "white");
		
			legend.style("font-size","16px")
			.call(xAxis);

		legend.select(".domain")
			.remove();
			
		legend.selectAll("rect")
			.data(threshold.range().map(function(color) {
				var d = threshold.invertExtent(color);
				if (d[0] == null) d[0] = x.domain()[0];
				if (d[1] == null) d[1] = x.domain()[1];
				return d;
			}))
			.enter().insert("rect", ".tick")
			.attr("height", 12)
			.attr("y", 85)
			.attr("x", function(d) { return x(d[0])-75; })
			.attr("width", function(d) { return x(d[1]) - x(d[0]); })
			//.attr("transform", function(d) { return "rotate(90)" })
			.attr("fill", function(d) { return threshold(d[0]); })
			


		legend.append("text")
			.attr("fill", "#000")
			.attr("font-weight", "bold")
			.attr("text-anchor", "start")
			.attr("y", 26)
			.attr("x", 6)
			.style("font-size","22px")
			.style("font-family", typo) 
			.text(headline);

			   

		
		if (rseries == "h" && hourly != "no"){shownformat = dateparser(mapdate)+":00"}
		else {shownformat = dateparser(mapdate)}
		legend.append("text")
			.attr("fill", "#000")
			//.attr("font-weight", "bold")
			.attr("text-anchor", "start")
			.attr("y", 60)
			.attr("x", 6)
			.style("font-size","18px")
			.style("font-family", typo) 
			.text(shownformat);
			
// functions 
		function setup(width,height){
			//projection = d3.geo.mercator()
			if (width > 600){
			projection =d3.geo.naturalEarth()
				.translate([(tran1+(height + margin.top + margin.bottom-300)), (tran2+(height + margin.top + margin.bottom-300)*2)])				//ganz europa bei einer höhe von 300px: 75,470 scale 350
				.scale( sca+(height + margin.top + margin.bottom-300)*1.5);																			//Zoomstufe (kleinere Zahl --> weniger Zooom)
			}
			else {
			projection =d3.geo.naturalEarth()
				.translate([(tran1+(height + margin.top + margin.bottom-300)*1.8), (tran2+(height + margin.top + margin.bottom-300)*2)])				//ganz europa bei einer höhe von 300px: 75,470 scale 350
				.scale( sca+(height + margin.top + margin.bottom-300)*1.5);																			//Zoomstufe (kleinere Zahl --> weniger Zooom)
			}
			path = d3.geo.path().projection(projection)		 
		}			
			
	}	
}}}

// Create an export button
//d3.select("body")
//   .append("button")
//  .html("Export")
//    .on("click",svgToCanvas);


// Create the export function - this will just export 
// the first svg element it finds
function svgToCanvas(){
    // Select the first svg element
    var svg = d3.select("svg"),
        img = new Image(),
        serializer = new XMLSerializer(),
        width = 2000,
        height = 2000;





    // generate IMG in new tab
    var svgStr = serializer.serializeToString(svg.node());
     img.src = 'data:image/svg+xml;base64,'+window.btoa(unescape(encodeURIComponent(svgStr)));
window.open().document.write('<img src="' + img.src + '"/>');
};

</script> 
</body>